\documentclass[titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorlinks=false]{hyperref}
\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}



\title{Spatially Balanced Latin Square (SBLS)}
\author{Daniel \sc Carriba Nosrati}
\date{Semestre 1 2025/2026}

\renewcommand{\contentsname}{Sommaire}

\hyphenpenalty=10000
\exhyphenpenalty=10000


\begin{document}


\begin{titlepage}
    \centering
    {\huge \bfseries Spatially Balanced\\Latin Square \par}
    \vspace{1cm}
    {\Large Modélisation et résolution du problème SBLS\\avec la Programmation par Contraintes\par}
    \vfill
    {\includegraphics[width=0.3\textwidth]{img/unice.png} \par}
    \vfill
    {\Large Daniel \sc Carriba Nosrati \par}
    \vspace{0.5cm}
    {\large UE Introduction à la Programmation par Contraintes\\Master 1 Informatique\\Université Côte d'Azur \par}
    \vspace{0.5cm}
    {\large Semestre 1 2025/2026 \par}
\end{titlepage}


\tableofcontents


\clearpage


\section{Introduction}

Ce projet a pour but de modéliser le problème SBLS avec la Programmation par Contraintes, et d'essayer de le résoudre pour le plus grand \( n \) possible.

\subsection{Présentation du problème SBLS}

Le problème SBLS (Spatially Balanced Latin Square), en français "Carré Latin Spatialement Équilibré", est un problème où on dispose d'un carré de taille \( n \times n \) (pour un \( n \) donné) et qui possède les mêmes contraintes que le problème du Carré Latin, soit pour chaque ligne et colonne il y a exactement une seule occurence de \( i \) \( \forall i \in [0, n-1] \), autrement dit tout les éléments sont tous différents un à un au sein d'une ligne et d'une colonne, pour toute ligne et colonne du carré \( n \times n \).

Le problème SBLS (ou Carré Latin Spatialement Équilibré) possède une contrainte supplémentaire comparé au problème du Carré Latin. Cette contrainte supplémentaire contraint que la somme des distances entre chaque paire de nombres \( i \) et \( j \) est égale, \( \forall i \in [0, n-1] \), \( \forall j \in [0, n-1] \).

\subsection{Présentation du projet}

Dans ce projet, le problème SBLS à été modélisé avec la Programmation par Contraintes grâce à la librairie Java \href{https://choco-solver.org/}{Choco-solver}. Plusieurs méthodes de résolution différentes ont étés implémentées, qui seront comparé à une méthode dite "simple".

Dans ce rapport on présentera la méthode dite "simple" ainsi que les autres méthodes de résolution qui ont étés implémentées dans notre programme. De plus on présentera pour tout \( n \) les différentes statistiques de résolution des différentes méthodes implémentées, comme le temps de résolution ou encore le nombre de noeuds utilisés.

\subsection{Matériel utilisé}

Les statistiques calculées par notre programme et présentées dans ce rapport ont été réalisées sur la machine suivante :

\begin{itemize}
\item \href{https://support.apple.com/fr-fr/111902}{Apple MacBook Pro (14 pouces, 2021)}
\item CPU : Apple M1 Pro, 8 c\oe urs CPU (dont 6 hautes performances et 2 à haute efficacité énergétique)
\item GPU : Apple M1 Pro, 14 c\oe urs GPU
\item RAM : 16 Go de mémoire unifiée
\item OS : macOS Sequoia 15.7.1
\end{itemize}

\par 

\href{https://www.oracle.com/fr/java/technologies/downloads/#java21}{Java version 21.0.8 distribué par Oracle} ainsi que \href{https://github.com/chocoteam/choco-solver/releases/tag/v4.10.14}{Choco-solver version 4.10.14} ont été utilisés.

\clearpage


\section{Modélisation}

Pour pouvoir implémenter et résoudre le problème SBLS avec Choco-solver, on a choisit de modéliser le problème SBLS avec les variables, les domaines et les contraintes suivantes.

\subsection{Variables}

Les variables de notre problème seront représentés par \( Variables \) de type \verb|IntVar[][]|, soit une matrice d'éléments de type \verb|IntVar|.

\(Variables\) est définit mathématiquement de la manière suivante :
\[
Variables = \{ v_{i, j}, \forall i \in [0, n-1], \forall j \in [0, n-1] \}
\]
où \( v_{i, j} \) représente la valeur au sein de la cellule \( (i, j) \), i.e. la cellule de la ligne \( i \in [0, n-1] \) et de la colonne \( j \in [0, n-1] \) du carré \( n \times n \).

Dans notre programme \( Variables \) est définit de la manière suivante :
\begin{verbatim}
private IntVar[][] variables;
variables = model.intVarMatrix(n, n, 0, n-1);
\end{verbatim}


\subsection{Domaines}

Les domaines des variables est définit mathématiquement de la manière suivante:
\[
Domaines = \{ D_{i, j}, \forall i \in [0, n-1], \forall j \in [0, n-1] \}
\]
avec
\[
D_{i, j} = \{0, \dots , n-1\}, \forall i \in [0, n-1], \forall j \in [0, n-1]
\]
où \( D_{i, j} \) est le domaine de la variable \( v_{i, j} \), \( \forall i \in [0, n-1], \forall elt \in [0, n-1] \)
\\ \par

Cela signifie que toute cellule \( (i, j) \) du carré \( n \times n \) peut prendre pour valeur entre \(0\) et \(n-1\).

\subsection{Contraintes}

\subsubsection{Contrainte sur les lignes}

La première contrainte du problème SBLS proscrit que il y a exactement une seule occurence de chaque élément \( elt \) au sein d'une ligne \( i \) du carré \(n \times n \) \( \forall i \in [0, n-1] \).

Dans notre modélisation, la variable \(v_{i, j}\) représente la valeur de la cellule \( (i, j) \) du carré \( n \times n \).

Ainsi, cette première contrainte est mathématiquement défini de la manière suivante :

\[
\forall i \in [0, n-1], v_{i, 0} \neq v_{i, 1} \neq \dots \neq v_{i, n-1}
\]
ce qui signifie que pour toute ligne \( i \) du carré \( n \times n \) tout \( elt \in [0, n-1] \) est à une position différente.

Dans notre programme cette contrainte à été implémentée de la manière suivante :
\begin{verbatim}
for (int i = 0; i < n; i++) {
    model.allDifferent(variables[i]).post();
}
\end{verbatim}

\subsubsection{Contrainte sur les colonnes}

La seconde contrainte du problème SBLS proscrit que il y a exactement une seule occurence de chaque élément \( elt \) au sein d'une colonne \( j \) du carré \(n \times n \) \( \forall j \in [0, n-1] \).

Dans notre modélisation, la variable \(v_{i, j}\) représente la valeur de la cellule \( (i, j) \) du carré \( n \times n \).

Ainsi, cette seconde contrainte est mathématiquement défini de la manière suivante :

\[
\forall j \in [0, n-1], v_{0, j} \neq v_{1, j} \neq \dots \neq v_{n-1, j}
\]
ce qui signifie que pour toute colonne \( j \) du carré \( n \times n \) tout \( elt \in [0, n-1] \) est à une position différente.

Dans notre programme cette contrainte à été implémentée de la manière suivante :
\begin{verbatim}
for (int j = 0; j < n; j++) {
    IntVar[] column = new IntVar[n];

    for (int i = 0; i < n; i++) {
        column[i] = variables[i][j];
    }

    model.allDifferent(column).post();
}
\end{verbatim}

\subsubsection{Contrainte sur l'équilibre spatiale}

La troisième et dernière contrainte du problème SBLS est la contrainte sur l'équilibre spatiale. Pour respecter cette contrainte il faut que toutes les sommes des distances entre deux éléments \( elt1 \) et \( elt2 \) soit égales, pour tout couple d'éléments \( (elt1, elt2) \) \( \forall elt1 \in [0, n-1], \forall elt2 \in [0, n-1 \).

Ainsi, cette contrainte est mathématiquement défini de la manière suivante :

\begin{align*}
EnsembleSommes &= \left\{
\forall elt1 \in [0, n-1], \forall elt2 \in [0, n-1], \sum_{i = 0}^{n-1} \left( distance(elt1, elt2) \text{ au sein de la ligne } i \right)
\right\} \\
&\bigcup 
\left\{
\forall elt1 \in [0, n-1], \forall elt2 \in [0, n-1], \sum_{j = 0}^{n-1} \left( distance(elt1, elt2) \text{ au sein de la ligne } j \right)
\right\}
\end{align*}

\[
\forall sum_{k} \in EnsemblesSommes, sum_{0} = sum_{1} = ...
\]

Dans notre programme cette contrainte à été implémentée en suivant le pseudo-code\\suivant :
\begin{verbatim}
sommesDistances = {}
pour elt1 dans Elements :
    pour elt2 dans Elements :
        sommeDistanceLigne = 0
        pour toute ligne i du carre n*n :
            sommeDistanceLigne += Distance(elt1, elt2)
        sommeDistanceColonne = 0
        pour toute colonne j du carre n*n :
            sommeDistanceColonne += Distance(elt1, elt2)
        nouvelleContrainte(sommeDistanceLigne = sommeDistanceColonne)
        sommesDistances.ajouter(sommeDistanceLigne)
nouvelleContrainte(sommesDistances.tousEgaux)
\end{verbatim}

\clearpage

\section{Méthodes de résolution}

\subsection{Méthode simple}

\subsection{Méthode avancée}

\clearpage

\section{Résultats}

\subsection{Méthode simple}

\begin{table}[h]
\centering
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}} | c | c c c c c c | @{}}
\hline
& n=2 & n=3 & n=4 & n=5 & n=6 & n=7\\
\hline
Solution Found & Yes & Yes & No & Yes & Yes & ?\\
Building time (in s) & 0,041 & 0,055 & 0,071 & 0,122 & 0,203 & ? \\
Resolution Time (in s) & 0,022 & 0,033 & 0,518 & 0,228 & 39,315 & ? \\
Nodes & 2  & 7 & 485 & 76 & 10944 & ? \\
Nodes per second & 89,6 & 215 & 936,4 & 333,9 & 278,4 & ? \\
Backtracks & 0 & 0 & 971 & 55 & 21671 & ? \\
Backjumps & 0 & 0 & 0 & 0 & 0 & ? \\
Fails & 0 & 0 & 486 & 29 & 10842 & ? \\
Restarts & 0 & 0 & 0 & 0 & 0 & ? \\
\hline
\end{tabular*}
\caption{Résultats d'exécutions de la méthode de résolution simple}
\end{table}

Après plus de 30 minutes, la méthode de résolution simple n'avait pas produit de résultats pour n=7

\subsection{Méthode avancée}

\clearpage

\section{Conclusion}

\end{document}
